const express = require('express');
const axios = require('axios');
const cheerio = require('cheerio');
const crypto = require('crypto');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const compression = require('compression');

const app = express();
const port = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(helmet());
app.use(compression());
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Quantum encryption simulation
const quantumEncrypt = (data) => {
  const algorithm = 'aes-256-cbc';
  const key = crypto.randomBytes(32);
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return { encrypted, key: key.toString('hex'), iv: iv.toString('hex') };
};

// AI content filter simulation
const aiContentFilter = (content) => {
  const sensitiveWords = ['offensive', 'inappropriate', 'explicit'];
  const regex = new RegExp(sensitiveWords.join('|'), 'gi');
  return content.replace(regex, match => '*'.repeat(match.length));
};

// Wormhole routing simulation
const optimizeRoute = (url) => {
  const hash = crypto.createHash('sha256').update(url).digest('hex');
  return `https://quantum-optimized-${hash.substr(0, 8)}.nexus/${url}`;
};

// Main proxy route
app.post('/quantum-proxy', async (req, res) => {
  try {
    let { url, quantumEncryption, aiContentFilter: useAiFilter, wormholeRouting } = req.body;

    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://' + url;
    }

    const start = Date.now();

    if (wormholeRouting) {
      url = optimizeRoute(url);
    }

    const response = await axios.get(url);
    let content = response.data;

    if (useAiFilter) {
      content = aiContentFilter(content);
    }

    if (quantumEncryption) {
      const encryptedData = quantumEncrypt(content);
      content = encryptedData.encrypted;
    }

    // Modify links and resources to go through the proxy
    const $ = cheerio.load(content);
    $('a').each((i, el) => {
      const href = $(el).attr('href');
      if (href && !href.startsWith('http')) {
        $(el).attr('href', `/quantum-proxy?url=${encodeURIComponent(new URL(href, url).href)}`);
      }
    });

    $('img, script, link').each((i, el) => {
      const src = $(el).attr('src') || $(el).attr('href');
      if (src && !src.startsWith('http')) {
        const attr = $(el).attr('src') ? 'src' : 'href';
        $(el).attr(attr, `/quantum-proxy?url=${encodeURIComponent(new URL(src, url).href)}`);
      }
    });

    const end = Date.now();
    const stats = {
      time: end - start,
      size: Buffer.byteLength(content, 'utf8')
    };

    res.json({ content: $.html(), stats });
  } catch (error) {
    res.status(500).json({ error: `Quantum anomaly detected: ${error.message}` });
  }
});

// Static file serving for the frontend
app.use(express.static('public'));

app.listen(port, () => {
  console.log(`Quantum Web Explorer backend running on port ${port}`);
});
